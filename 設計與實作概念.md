# 檔案系統設計 — 設計與實作概念

## 1. 系統架構概覽

本專案以 **ASP.NET Core 8 Web API + Vue 3 SPA** 實作一套虛擬檔案管理系統，採用前後端分離架構：

| 層級 | 技術 |
|------|------|
| 後端 | ASP.NET Core 8 Web API |
| 資料庫 | SQLite + Entity Framework Core (Code-First) |
| 前端 | Vue 3 (Composition API) + Element Plus + Vite |
| 通訊 | RESTful API (JSON)，前端透過 Axios 呼叫 |

後端 Service Layer 依照 **Single Responsibility Principle (SRP)** 拆分為三個獨立服務：

```
┌──────────────────────────────────────────────────┐
│  Vue 3 Frontend (SPA)                            │
│  ┌────────┐ ┌──────────┐ ┌───────────────────┐   │
│  │FileTree│ │ ItemInfo │ │  ConsolePanel     │   │
│  └───┬────┘ └────┬─────┘ └────────┬──────────┘   │
│      └───────────┼────────────────┘               │
│           HomePage.vue (Orchestrator)             │
│           useUndoRedo() (Command Pattern)         │
│                    │ Axios                        │
├────────────────────┼─────────────────────────────┤
│  ASP.NET Core Backend                            │
│  ┌─────────────────▼──────────────────────────┐  │
│  │        FileSystemController (REST)         │  │
│  └──────┬──────────┬──────────┬───────────────┘  │
│         │          │          │                   │
│  ┌──────▼───┐ ┌────▼─────┐ ┌─▼──────────┐       │
│  │ Query    │ │ Command  │ │ Tag        │       │
│  │ Service  │ │ Service  │ │ Service    │       │
│  └──────┬───┘ └────┬─────┘ └─┬──────────┘       │
│         │          │          │                   │
│  ┌──────▼──────────▼──────────▼───────────────┐  │
│  │  Domain Models (Composite Pattern)         │  │
│  │  AppDbContext (EF Core + SQLite)           │  │
│  │  ItemMapper / FileFactory                  │  │
│  └────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────┘
```

每個 Service 透過介面注入 Controller，職責明確且可獨立測試。

---

## 2. Design Patterns 與對應功能

### 2.1 Composite Pattern — 檔案/目錄樹狀結構

**解決的問題**：檔案系統天然具有樹狀遞迴結構，目錄可以包含檔案或子目錄。如果不用統一介面，每次操作都需要用 `if/else` 判斷「這是目錄還是檔案」，隨著操作增加，分支邏輯會快速膨脹。

**角色對應**：

| Composite 角色 | 系統類別 | 說明 |
|----------------|----------|------|
| Component | `FileSystemItem` | 抽象基類，定義 `GetTotalSize()`、`SearchByExtension()`、`ToXml()`、`Traverse()`、`Display()` 等統一介面 |
| Composite | `Directory` | 持有 `List<FileSystemItem> Items`，遞迴委派操作給子項目 |
| Leaf | `File`（及其子類） | 不包含子項目，直接回傳自身資料 |

```
FileSystemItem (abstract)          ← Component
├── Directory                      ← Composite（含 List<FileSystemItem> Items）
└── File (abstract)                ← Leaf
    ├── WordFile     (+Pages)
    ├── ImageFile    (+Width, Height)
    └── TextFile     (+Encoding)
```

**核心機制**：客戶端呼叫 `item.GetTotalSize()` 時，不需要知道 item 是目錄還是檔案，多型自動處理遞迴邏輯：

```csharp
// Directory — 遞迴加總
public override double GetTotalSize()
    => Size + Items.Sum(item => item.GetTotalSize());

// File — 終端回傳
public override double GetTotalSize()
    => Size;
```

**如果不用 Composite**：每個操作（計算大小、搜尋、匯出 XML）都需要寫 `if (item is Directory) { foreach... } else { ... }`，程式碼重複且難以擴充。新增操作只需在抽象基類加 abstract method，各子類別各自 override，不影響既有程式碼。

---

### 2.2 Factory Pattern — 建立檔案

**解決的問題**：前端傳入的 CreateFileDto 可能是 Word、Image 或 Text，需要根據不同類型建立不同的 Model 物件。如果把建立邏輯寫在 Service 裡，會讓 Service 耦合所有檔案類型的建構細節。

**實作方式**：

```csharp
public class FileFactory
{
    public File Create(CreateFileDto dto) => dto switch
    {
        CreateWordFileDto w  => new WordFile  { ... Pages = w.Pages },
        CreateImageFileDto i => new ImageFile { ... Width = i.Width, Height = i.Height },
        CreateTextFileDto t  => new TextFile  { ... Encoding = t.Encoding },
        _ => throw new ArgumentException("不支援的檔案類型")
    };
}
```

搭配 `[JsonPolymorphic]` 讓 ASP.NET Core 在 API 入口自動依 `$type` 反序列化為對應的 DTO 子類別，整條鏈路（JSON → DTO → Factory → Model）都是型別安全的。

**效果**：`CommandService.CreateFileAsync()` 只需呼叫 `_fileFactory.Create(dto)`，不需要知道有哪些檔案類型。新增檔案類型時只需：
1. 新增 Model 子類別
2. 新增 DTO 子類別
3. 在 FileFactory 加一行 case

**如果不用 Factory**：建立邏輯散落在 Service 中，每次新增檔案類型都要改 Service，違反 Open-Closed Principle。

---

### 2.3 Template Method Pattern — 檔案顯示

**解決的問題**：所有檔案的 `Display()` 方法有相同的骨架（縮排 + 連接符 + 檔名 + 詳細資訊），但「詳細資訊」因檔案類型而異（Word 顯示頁數、Image 顯示解析度、Text 顯示編碼）。

**實作方式**：

```csharp
// File.cs — 固定框架（Template Method）
public override string Display(string indent, bool isLast)
{
    var connector = isLast ? "└── " : "├── ";
    return $"{indent}{connector}{Name} {GetFileDetails()}";  // 骨架固定
}

protected abstract string GetFileDetails();  // 延遲到子類實作
```

| 子類別 | GetFileDetails() 回傳 |
|--------|----------------------|
| WordFile | `[Word 檔案] (頁數: 10, 大小: 50KB)` |
| ImageFile | `[圖片] (解析度: 1920x1080, 大小: 200KB)` |
| TextFile | `[純文字檔] (編碼: UTF-8, 大小: 5KB)` |

**如果不用 Template Method**：每個子類都要重寫完整的 Display 方法，排版邏輯重複三次，改一處要改三處。

---

### 2.4 Command Pattern — Undo/Redo

**解決的問題**：使用者執行新增目錄、新增檔案、刪除、切換標籤等操作後，需要能復原（Undo）和重做（Redo）。

**實作方式**（前端 Vue 3 Composable）：

每個操作封裝為一個 command 物件：

```javascript
const command = {
    name: '新增目錄',
    execute: async () => { /* 呼叫 API 建立 */ },
    undo: async () => { /* 呼叫 API 刪除 */ }
}
```

`useUndoRedo` composable 管理兩個堆疊：

```
undoStack: [ cmd1, cmd2, cmd3 ]  ← 最新操作在頂端
redoStack: [ cmd4 ]              ← 被復原的操作

執行操作 → undoStack.push(cmd), redoStack.clear()
復原    → cmd = undoStack.pop(), cmd.undo(), redoStack.push(cmd)
重做    → cmd = redoStack.pop(), cmd.execute(), undoStack.push(cmd)
```


**為何放前端而非後端**：所有可復原操作都已有對應的 REST API，`undo()` 只是呼叫反向 API，前端維護 stack 即可，不需後端額外建立操作歷史資料表。

**如果不用 Command**：Undo/Redo 邏輯會散落在各個事件處理函式中，難以統一管理堆疊，也無法輕易擴充新的可復原操作。

---

### 2.5 Observer Pattern — 進度觀察面板

**解決的問題**：遞迴計算大小或搜尋可能遍歷數十個節點，使用者需要知道「目前進行到哪裡」，而非等待一個空白畫面。

**實作方式**：Vue 3 的響應式系統天然實現了 Observer Pattern：

```
HomePage (Subject)                    ObserverPanel (Observer)
  │                                      │
  ├─ processedNodes++  ──watch()──►  更新進度條
  ├─ currentProcessingNode = "..."  ──►  顯示節點名稱
  └─ 操作完成          ──watch()──►  10 秒後自動隱藏
```

| Observer 角色 | 對應 |
|---------------|------|
| Subject | 父元件的 reactive state（`currentProcessingNode`） |
| Observer | ObserverPanel 元件（watch + UI 更新） |

**為何不用 EventBus 或 Vuex**：本系統只有一個 Observer 和一個 Subject，透過 props + watch 已足夠，引入狀態管理庫屬 over-engineering。

---

## 3. 資料庫選型與設計

### 3.1 為什麼選 SQLite

| 考量面向 | SQLite 的優勢 | 與其他方案比較 |
|---------|-------------|--------------|
| **零配置部署** | 不需安裝資料庫伺服器，單一 `filesystem.db` 檔案，`dotnet run` 即啟動 | SQL Server / PostgreSQL 需額外安裝與設定連線 |
| **適合展示專案** | 本系統為展示 Design Pattern 的作業專案，資料量小（數十~數百筆），不需要高併發或分散式能力 | 大型 RDBMS 在此場景屬 overkill |
| **EF Core 完整支援** | SQLite provider 支援 Migration、TPH、索引、多對多等全部功能 | 切換到其他 DB 只需換 provider，不需改 Model 或 DbContext |
| **跨平台** | 評審在 Windows、macOS、Linux 上皆可直接 `dotnet run`，無環境依賴 | SQL Server 在 macOS 需透過 Docker |

> **取捨**：SQLite 不適合高寫入併發（單寫入鎖），但本系統為單人操作的 Demo 應用，完全在可接受範圍內。


### 3.2 資料表結構

```
FileSystemItems（TPH 單一資料表）
├── Id          : GUID (PK)
├── Name        : TEXT
├── Size        : REAL
├── CreatedDate : DATETIME
├── ParentId    : GUID (FK → self, nullable)  ← 自我參照
├── ItemType    : TEXT (Discriminator)          ← TPH 鑑別器
├── Pages       : INTEGER (nullable)            ← WordFile
├── Width       : INTEGER (nullable)            ← ImageFile
├── Height      : INTEGER (nullable)            ← ImageFile
└── Encoding    : TEXT (nullable)               ← TextFile

Tags
├── Id    : GUID (PK)
├── Name  : TEXT
└── Color : TEXT

FileSystemItemTags（多對多聯結表，EF Core 自動產生）
├── FileSystemItemId : GUID (PK, FK)
└── TagId            : GUID (PK, FK)
```

- **自我參照 FK**：`ParentId → Id` 實現目錄的父子關係，根目錄的 ParentId 為 NULL
- **多對多**：透過聯結表讓任意項目可掛上多個標籤
- **索引**：ParentId 和 Name 欄位建立索引，加速樹載入和名稱查詢

---

## 4. 面對大資料量的架構設計


### 4.1 AsNoTracking — 唯讀查詢優化

EF Core 預設會追蹤（Track）每個查詢回來的實體，以便偵測變更。在唯讀場景（查詢樹、搜尋）中，追蹤是不必要的開銷。

加上 `.AsNoTracking()` 後：
- 不建立 Change Tracker 快照，降低記憶體使用
- 查詢速度更快（不需建立 Identity Map）
- 寫入操作（Create、Delete）則使用正常追蹤模式


### 4.2 批次刪除策略

刪除一個目錄時需要連同所有後代一起刪除。策略是：

1. 一次查詢撈出所有項目（tracked，不用 AsNoTracking）
2. 在記憶體中用 `ToLookup` 建立父子關係
3. 遞迴收集所有後代 ID 到 `HashSet`
4. `RemoveRange` 批次刪除

避免了逐筆刪除產生的多次 SQL，改為單次批次操作。

### 4.3 索引設計

```csharp
modelBuilder.Entity<FileSystemItem>().HasIndex(f => f.ParentId);  // 加速樹載入
modelBuilder.Entity<FileSystemItem>().HasIndex(f => f.Name);      // 加速名稱查詢
```

---

## 5. API 端點總覽

| 方法 | 路徑 | 功能 | 負責 Service |
|------|------|------|-------------|
| GET | `/api/filesystem/tree` | 取得完整目錄樹 | QueryService |
| GET | `/{id}` | 取得單一項目 | QueryService |
| GET | `/{id}/size` | 遞迴計算總大小 + Traverse Log | QueryService |
| GET | `/search/extension?ext=.docx` | 副檔名搜尋 | QueryService |
| GET | `/{id}/xml` | XML 結構輸出 | QueryService |
| GET | `/console` | 樹狀 Console 文字 | QueryService |
| GET | `/{id}/traverse-log` | 取得走訪紀錄 | QueryService |
| POST | `/directory` | 建立目錄 | CommandService |
| POST | `/file` | 建立檔案 | CommandService |
| PUT | `/{id}/rename` | 重新命名 | CommandService |
| DELETE | `/{id}` | 刪除項目 | CommandService |
| GET | `/tags` | 取得所有標籤 | TagService |
| POST | `/{id}/tags/{tagId}` | Toggle 標籤 | TagService |

---

## 6. 如何執行

### 後端
```bash
cd WinbondProj
dotnet run
# 預設啟動於 http://localhost:5089
# Swagger UI: http://localhost:5089/swagger
```

### 前端
```bash
cd vue-frontend
npm install
npm run dev
# 預設啟動於 http://localhost:5173
```

首次啟動後端時，`DbInitializer` 會自動建立 SQLite 資料庫並 Seed 範例資料。
